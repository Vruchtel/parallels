#pragma once

#include <mutex>
#include <condition_variable>

class Barrier
{
public:
	// Задаёт число потоков, которые будут проходить через барьер
	Barrier(std::size_t numThreads);

	// Конструктор по-умолчанию, конструктор копирования и оператор присваивания запрещены
	Barrier() = delete;
	Barrier(const Barrier &otherBarrier) = delete;
	Barrier &operator=(const Barrier &otherBarrier) = delete;

	// Деструктор - по-умолчанию
	~Barrier() = default;

	// Когда поток хочет пройти через барьер, он вызывает этот метод и блокируется до тех пор, пока остальные потоки не его не вызовут
	// Поток, последним вызвавщий Enter() разблокирует все ожидающие потоки, после чего барьер считается пройденным
	void Enter();

private:
	std::size_t _numThreads;  // Число потоков, которые будут проходить через барьер, задаётся при создании в конструкторе

	std::size_t _wantCounter;  // Счётчик потоков, которые подошли к барьеру, обнуляется, когда равен _numThreads
							   // и при инициализации барьера

	std::size_t _eraCounter;  // Счётчик эпох, инкрементируется, когда все потки подошли к барьеру, равен нулю при инициализации барьера

	std::mutex _barrierGate;  // Мьютекс на проход через барьер, 
							  // поток блокируется на этом мьютексе до тех пор, пока все потоки не подойдут к барьеру

	std::condition_variable _waitAll;  // notify_all будет вызван, когда все потоки подойдут к барьеру
};
